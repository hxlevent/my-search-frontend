// 날짜 범위를 "YYYY.MM.DD" 문자열 배열로 생성
function getDateRange(startStr, endStr) {
  const toDate = (s) => {
    const [Y, M, D] = s.split('.').map(Number);
    return new Date(Y, M - 1, D);
  };
  const fmt = (d) => {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}.${m}.${day}`;
  };
  const res = [];
  let cur = toDate(startStr);
  const end = toDate(endStr);
  while (cur <= end) {
    res.push(fmt(cur));
    cur.setDate(cur.getDate() + 1);
  }
  return res;
}

// 날짜 문자열 "YYYY.MM.DD" → "M/D" 표기
function toMD(dateStr) {
  const parts = dateStr.split('.').map(Number);
  return `${parts[1]}/${parts[2]}`;
}

// "H:MM" 또는 "HH:MM" → 분(min)으로 변환 (예: "0:39" → 39)
function timeToMinutes(t) {
  if (!t) return null;
  const [h, m] = t.split(':').map(Number);
  if (Number.isNaN(h) || Number.isNaN(m)) return null;
  return h * 60 + m;
}

// ★ 기존 함수를 이 버전으로 교체
function renderUIDTable(rows){
  const wrap = qs('uidResults');
  if (!rows || rows.length === 0) {
    wrap.innerHTML = '<p>검색 결과가 없습니다.</p>';
    return;
  }

  // 1) 날짜 범위: 입력 없으면 이벤트 기본범위 사용
  const df = qs('uidDateFrom').value.trim();
  const dt = qs('uidDateTo').value.trim();
  const startStr = df || '2025.09.19';
  const endStr   = dt || '2025.09.25';
  const days = getDateRange(startStr, endStr); // ["2025.09.19", ..., "2025.09.25"]

  // 2) 날짜별 건수 집계 + 9/25 특수 분리
  const counts = Object.fromEntries(days.map(d => [d, 0]));
  let count25_first = 0; // 00:00~09:59
  let countLive     = 0; // 12:00~23:59
  // 25일 문자열 찾기 (범위에 25일이 포함된 경우)
  const day25 = days.find(d => d.endsWith('.09.25') || d.endsWith('.9.25') || d.endsWith('.25'));

  rows.forEach(r => {
    const d = r['날짜'];
    const t = r['시간'];
    if (!d) return;

    // 범위 밖이면 스킵
    if (!counts.hasOwnProperty(d)) return;

    if (day25 && d === day25) {
      const mins = timeToMinutes(t);
      if (mins !== null) {
        if (mins <= 9*60 + 59) {
          count25_first += 1;      // 9/25(1차)
        } else if (mins >= 12*60) {
          countLive += 1;          // 생방
        } else {
          // 10:00 ~ 11:59 사이 → 요약표에는 미반영 (상세표에는 그대로 표시)
        }
      }
    } else {
      counts[d] += 1; // 일반 날짜는 전부 카운트
    }
  });

  // 3) 요약 표 헤더 구성: 9/19~24 + (9/25(1차), 생방)
  const headerDates = [];
  const headerLabels = [];
  days.forEach(d => {
    if (day25 && d === day25) {
      headerDates.push(d + '_first'); headerLabels.push(toMD(d) + '(1차)');
      headerDates.push(d + '_live');  headerLabels.push('생방');
    } else {
      headerDates.push(d);            headerLabels.push(toMD(d));
    }
  });

  // 4) 요약 표 바디(숫자 표기)
  const summaryCells = headerDates.map(key => {
    if (key.endsWith('_first')) return count25_first;
    if (key.endsWith('_live'))  return countLive;
    const orig = key; // 일반 날짜 키
    return counts[orig] ?? 0;
  });

  // 5) 개근 판정: 19~24일 모두 1건 이상 && 25(1차) 1건 이상
  let perfect = true;
  const needDates = days.filter(d => !day25 || d !== day25); // 19~24일
  for (const d of needDates) {
    if ((counts[d] || 0) < 1) { perfect = false; break; }
  }
  if (day25 && count25_first < 1) perfect = false;

  // 6) 요약 표 HTML
  let summary = '<table><thead><tr><th style="min-width:110px">참여 요약</th>';
  headerLabels.forEach(lbl => summary += `<th>${lbl}</th>`);
  summary += '</tr></thead><tbody>';
  summary += `<tr><td>건수</td>${summaryCells.map(c => `<td style="text-align:center">${c}</td>`).join('')}</tr>`;
  summary += `<tr><td>개근</td><td colspan="${headerLabels.length}" style="text-align:center;font-weight:600">${perfect ? 'o' : 'x'}</td></tr>`;
  summary += '</tbody></table>';

  // 7) 상세 표 (원래대로)
  let detail = '<table style="margin-top:12px"><thead><tr>' +
    '<th>고유번호</th><th>날짜</th><th>시간</th><th>인증샷 시리얼넘버</th>' +
    '</tr></thead><tbody>';
  rows.forEach(r => {
    const serial = r['인증샷 시리얼넘버'] ?? r['인증샷시리얼넘버'] ?? '';
    detail += `<tr>
      <td>${escapeHtml(r.unique_id ?? '')}</td>
      <td>${escapeHtml(r['날짜'] ?? '')}</td>
      <td>${escapeHtml(r['시간'] ?? '')}</td>
      <td>${escapeHtml(serial)}</td>
    </tr>`;
  });
  detail += '</tbody></table>';

  // 8) 렌더
  wrap.innerHTML = summary + detail;
}
